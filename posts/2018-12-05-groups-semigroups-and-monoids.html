<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Robert Stefanic - Groups, Monoids, and Semigroups</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>
        <header>
            <div class="logo">
                <a href="../">Robert Stefanic</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../contact.html">Contact</a>
                <a href="../photos.html">Photos</a>
                <a href="../blog.html">Blog</a>
                <a href="https://github.com/rstefanic" target="_blank">GitHub</a>
            </nav>
        </header>

        <main role="main">
            <article>
    <h1>Groups, Monoids, and Semigroups</h1>
    <section class="header">
        Posted on December  5, 2018
        
            by Robert
        
    </section>
    <section>
        <p>I want to explore the relationship between Groups, Monoids, and Semigroups. These abstract algebras are powerful, and in programming, once a data structure has built around one of these algebras, it can change how we understand the data that we’re manipulating and help us reason about the data that we’re working with.</p>
<p>My goal here is to give a formal definition for each of these algebras, and then give real world code exampels for each of them. Perhaps in the future, I’ll write another post where I explore other algebraic structures such as magmas/groupoids, abelians, or semilattices.</p>
<hr />
<h2 id="definitions">Definitions</h2>
<h3 id="semigroups">Semigroups</h3>
<p>Before we build up to notion of groups, let’s start with semigroups. After all, a semigroup is a partial group. A semigroup is a set (i.e. collection) that has an associative binary operation.</p>
<p>Let’s quickly refresh what a binary operation is and what it means for something to be associative.</p>
<p>A binary operation is a function that takes two elements of them same set, and outputs another element from that set.<a href="#note-1"><sup>1</sup></a> Examples of this are fairly obvious such as addition (+), subtraction (-), string concatenation, etc.</p>
<p>Haskell:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">(+) ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">(-) ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">(++) ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a></code></pre></div>
<p>C++:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="dt">int</span> add(<span class="dt">int</span> a, <span class="dt">int</span> b) {...}</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="dt">int</span> subtract(<span class="dt">int</span> a, <span class="dt">int</span> b) {...}</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="bu">std::</span>string concat(<span class="bu">std::</span>string a, <span class="bu">std::</span>string b) {...}</a></code></pre></div>
<p>The associativity property says that given a sequence of two or more binary operations, the order in which these operations are performed do not matter. An example of this would be addition, where <span class="math inline">1 + (2 + 3) = (1 + 2) + 3</span>. From the previous examples given, addition and string concatenation are associative binary operations, but subtraction is not associative because the order of operations matter in subtraction (<span class="math inline">1 − (2 − 3) ≠ (1 − 2) − 3</span>).<a href="#note-2"><sup>2</sup></a></p>
<p>So given set <span class="math inline"><em>S</em></span>, <span class="math inline"><em>S</em></span> is a semigroup if it has the binary operation of <span class="math inline"><em>f</em></span>, where <span class="math inline"><em>f</em></span> is associative.</p>
<p>\[f\colon S\times S\rightarrow S\]</p>
<p>\[\forall(\alpha, \beta, \delta)\in S\colon f(f(\alpha, \beta), \delta) = f(\alpha, f(\beta, \delta))\]</p>
<h3 id="monoids">Monoids</h3>
<p>Every monoid is a semigroup. In fact, if you look at the typeclass for Monoid in Haskell, you’ll see that Monoid requires Semigroup:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ot">  mempty ::</span> a</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">  mappend ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">  mconcat ::</span> [a] <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>So what exactly is the difference here? You’ll also notice that <code>mappend</code> in the definition for Monoid is the same as our definition of <span class="math inline"><em>f</em></span> from above.</p>
<p>Monoids are just semigroups that have an identity element. For element <span class="math inline"><em>x</em></span> (where <span class="math inline"><em>x</em></span> is any element from set <span class="math inline"><em>S</em></span>), when <span class="math inline"><em>x</em></span> and the identity element are combined with <span class="math inline"><em>f</em></span>, the result will always be <span class="math inline"><em>x</em></span>.</p>
<p>In the example of addition, the identity element would be 0 because <span class="math inline">0 + <em>x</em> = <em>x</em></span>. In the case of multiplication, the identity element would be 1 because <span class="math inline">1 ⋅ <em>x</em> = <em>x</em></span>. And in the case of string concatenation, the identity element would be an emtpy string because <code>&quot;&quot; + &quot;Hello!&quot; = &quot;Hello!&quot;</code>.</p>
<p>So given set <span class="math inline"><em>S</em></span>, <span class="math inline"><em>S</em></span> is a monoid if it has the binary operation of <span class="math inline"><em>f</em></span>, where <span class="math inline"><em>f</em></span> is associative and <span class="math inline"><em>S</em></span> has an identity element.</p>
<p>\[f\colon S\times S\rightarrow S\]</p>
<p>\[\forall(\alpha, \beta, \delta)\in S\colon f(f(\alpha, \beta), \delta) = f(\alpha, f(\beta, \delta))\]</p>
<p>\[\forall x \exists!e \in S\colon f(e, x) = x\]</p>
<h3 id="groups">Groups</h3>
<p>Just as monoids have all of the properties of a semigroup with an additional property, groups has all of the properties of a monoid with the additional property of an inverse operation.</p>
<p>An inverse operation says that given any element in the closed set, there is an inverse element that also exists. So to continue with our math examples, for every number in the set of all integers, for any number that you give me (e.g. 5), that number will always have a corresponding negative number (-5). So if set <span class="math inline"><em>S</em></span> is all the integers, and we have the addition operator, then <span class="math inline"><em>S</em></span> is a group.</p>
<p>In contrast to our other example of string concatenation, strings do not have a cooresponding inverse or reciprocal string; thus it cannot be a group. (What would the inverse of <code>&quot;Hello!&quot;</code> be?)</p>
<p>So to summarize, <span class="math inline"><em>S</em></span> is a group if it has the binary operation of <span class="math inline"><em>f</em></span>, where <span class="math inline"><em>f</em></span> is associative, <span class="math inline"><em>S</em></span> has an identity element, and for any element <span class="math inline"><em>x</em></span> in <span class="math inline"><em>S</em></span>, there exists element <span class="math inline"><em>y</em></span> in <span class="math inline"><em>S</em></span>, where <span class="math inline"><em>f</em></span> applied to <span class="math inline"><em>x</em></span> and <span class="math inline"><em>y</em></span> will yield the identity element.</p>
<p>\[f\colon S\times S\rightarrow S\]</p>
<p>\[\forall(\alpha, \beta, \delta)\in S\colon f(f(\alpha, \beta), \delta) = f(\alpha, f(\beta, \delta))\]</p>
<p>\[\forall x \exists!e \in S\colon f(e, x) = x\]</p>
<p>\[\forall x \exists y \in S\colon y = x^{-1}\]</p>
<p>\[\forall x \exists y \exists!e \in S\colon f(x, y) = e\]</p>
<hr />
<h2 id="groups-monoids-and-semigroups-in-the-wild">Groups, Monoids, and Semigroups in the Wild</h2>
<p>Alright, so now we know what these algebras are, but how do they apply to real world situations? I’ve come up with three examples to show how they may be used.</p>
<h3 id="semigroup-example">Semigroup Example</h3>
<p>Let’s say that we have a database with a really large view that we want to query, but we almost never need all of the fields from the view. This looks like it would be a great job for a semigroup!</p>
<p>In Haskell, we could create a type that would hold our query:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">SqlField</span> <span class="fu">=</span> <span class="dt">SqlField</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw">data</span> <span class="dt">SqlQuery</span> <span class="fu">=</span> <span class="dt">SqlQuery</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    {<span class="ot"> selectFields ::</span> <span class="dt">NonEmpty</span> <span class="dt">SqlField</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    ,<span class="ot"> fromTable    ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    ,<span class="ot"> whereClause  ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Since we could never select nothing from a table, <code>selectFields</code> must always have a value. So this looks like a great fit for a semigroup. We could define an instance for semigroup for <code>SqlQuery</code> that could combine two selectFields:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">SqlQuery</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    (<span class="dt">SqlQuery</span> fields t w) <span class="fu">&lt;&gt;</span> (<span class="dt">SqlQuery</span> fields' t' w') <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">        <span class="dt">SqlQuery</span> (fields <span class="fu">&lt;&gt;</span> fields') t w</a></code></pre></div>
<p>Now I have an easy way to combine two select clauses by just combining them by using <code>query1 &lt;&gt; query2</code>. And, like all semigroups, it’s associative, so I could just keep adding additinal fields to the query <code>((query1 &lt;&gt; query2) &lt;&gt; query3) == (query1 &lt;&gt; (query2 &lt;&gt; query3))</code>.</p>
<p>In a real situation, you’d want to expand <code>(&lt;&gt;)</code> by including a check to make sure that the fields in <code>fields</code> are different from the fields in <code>fields'</code> and to make sure that the the SqlQueries are pulling from the same table, but this was meant as a quick example of a semigroup.</p>
<h3 id="monoid-example">Monoid Example</h3>
<p>A common example for a monoid is a analong clock. It has an associtaive binary operation (the adding of hours) and an identity (the 12th hour). The monoid definition for a clock may look something like this:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Clock</span> <span class="fu">=</span> <span class="dt">Clock</span> <span class="dt">Int</span> </a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Clock</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    (<span class="dt">Clock</span> hour) <span class="fu">&lt;&gt;</span> (<span class="dt">Clock</span> hour') <span class="fu">=</span> <span class="dt">Clock</span> <span class="fu">$</span> (hour <span class="fu">+</span> hour') <span class="ot">`mod`</span> <span class="dv">12</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    mempty <span class="fu">=</span> <span class="dt">Clock</span> <span class="dv">12</span></a></code></pre></div>
<p>No matter how many hours you’re adding, you’ll never fall outside of the 12 hours of an analog clock.</p>
<h3 id="group-example">Group Example</h3>
<p>Groups, admittingly, are a bit more difficult to find in programming. They are a very useful concept in mathematics, but within programming, the pattern doesn’t appear very often.</p>
<p>One example though could be a colors that you’re keeping for a picture. It has an empty color (white), an associative binary operation that allows you to combine colors, and an operation that would give you that color’s negative.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Pixel</span> <span class="fu">=</span> <span class="dt">Pixel</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    {<span class="ot"> red   ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    ,<span class="ot"> green ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    ,<span class="ot"> blue  ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="ot">addColors ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">addColors x y <span class="fu">=</span> <span class="kw">if</span> val <span class="fu">&gt;</span> <span class="dv">255</span> <span class="kw">then</span> <span class="dv">255</span> <span class="kw">else</span> val</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    <span class="kw">where</span> val <span class="fu">=</span> x <span class="fu">+</span> y</a>
<a class="sourceLine" id="cb7-10" data-line-number="10"></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"><span class="ot">negateColor ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">negateColor x <span class="fu">=</span> <span class="dv">255</span> <span class="fu">-</span> x</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">                  </a>
<a class="sourceLine" id="cb7-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">Group</span> <span class="dt">Pixel</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-15" data-line-number="15">    mempty <span class="fu">=</span> <span class="dt">Pixel</span> <span class="dv">0</span> <span class="dv">0</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-16" data-line-number="16">    (<span class="dt">Pixel</span> r g b) <span class="fu">&lt;&gt;</span> (<span class="dt">Pixel</span> r' g' b') <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">        <span class="dt">Pixel</span> (addColors r r') (addColors g g') (addColors b b')</a>
<a class="sourceLine" id="cb7-18" data-line-number="18">    inverse (<span class="dt">Pixel</span> r g b) <span class="fu">=</span> </a>
<a class="sourceLine" id="cb7-19" data-line-number="19">        <span class="dt">Pixel</span> (negateColor r) (negateColor g) (negateColor b)</a></code></pre></div>
<hr />
<p><span id="note-1">1</span>: This is another good reason to used a type language because you can then add this information to your functions, where in duck typed langauges, your functions cannot enforce these contraints.</p>
<p><span id="note-2">2</span>: A set that has a single binary operation is known as a groupoid. So while subtraction is not a semigroup, it is a groupoid because it contains a closed binary operation, as this is the only requirement that needs to be met in order for something to be a groupoid. A closed binary operation just means that the binary operation always yeilds another member of the same set.</p>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll" target="_blank">Hakyll</a>. 
            You can view the code used to generate this site <a href="https://github.com/rstefanic/rstefanic.github.io/tree/hakyll" target="_blank">here</a>.
        </footer>
    </body>
</html>
